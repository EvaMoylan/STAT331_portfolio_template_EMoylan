---
title: "STAT 331 Portfolio"
author: "Eva Moylan"
date: "12/8/2024"
format: 
  html: 
    self-contained: true
layout: margin-left
editor: visual
execute: 
  eval: false
  echo: true
---

[**My Grade:**]{.underline} I believe my grade equivalent to course work evidenced below to be an A.

[**Learning Objective Evidence:**]{.underline} In the code chunks below, provide code from Lab or Challenge assignments where you believe you have demonstrated proficiency with the specified learning target. Be sure to specify **where** the code came from (e.g., Lab 4 Question 2).

## Working with Data

**WD-1: I can import data from a *variety* of formats (e.g., csv, xlsx, txt, etc.).**

-   `csv`

```{r}
#| label: wd-1-csv

#Lab 2- Question 1

surveys <- read_csv(here::here("data",
                               "surveys.csv")) #Load in data
```

-   `xlsx`

```{r}
#| label: wd-1-xlsx

#Check-in 2.3

AgesXLSX <- read_xlsx(here::here("Week 2", 
                                 "Ages_Data", 
                                 "ages.xlsx"), 
                      sheet = "ages") 
#Looks like first sheet is blank so this specifies to load the sheet named "ages" stored within the same file
```

-   `txt`

```{r}
#| label: wd-1-txt

#Check-in 2.3 

AgesMystery <- read_delim(here::here("Week 2", 
                                     "Ages_Data", 
                                     "ages_mystery.txt"), 
                          delim = "|") #This is not already spaced so add delim = "|" to separate lists
```

**WD-2: I can select necessary columns from a dataset.**

```{r}
#| label: wd-2

#Lab 3- Question 5

teacher_evals_clean <- evals |>
  rename(sex = gender) |> #rename gender column to 'sex'
  filter(no_participants >= 10) |> # remove all courses with fewer than 10 respondents
  mutate(teacher_id = as.factor(teacher_id), #change to a factor
         seniority = as.factor(seniority), #change to a factor
         question_no = question_no-900) |> #change question number to 1-10
  select(-(stud_grade_avg:stud_grade_var_coef_cur),
         -(class_duration:maximum_score)) #remove rows we don't need

```

**WD-3: I can filter rows from a dataframe for a *variety* of data types (e.g., numeric, integer, character, factor, date).**

-   numeric

```{r}
#| label: wd-3-numeric

#Lab 3- Question 10

#Teachers with the highest average rating for Q1
teacher_evals_clean |>
  filter(question_no == 1) |> 
  group_by(teacher_id, SET_score_avg) |>
  summarise(SET_score_avg = mean(SET_score_avg),
            .groups = "drop") |> #Average Q1 score for each teacher
  filter(SET_score_avg == max(SET_score_avg) |
         SET_score_avg == min(SET_score_avg)
         )

#Note: Original code was modified to filter using max and min arguments in one
      #pipeline instead of slice_min and slice_max in seperate pipelines.
```

-   character -- specifically a string (example must use functions from **stringr**)
-   factor

```{r}
#| label: wd-3-string-and-factor

#Lab 5- Applying Witness Accounts

#Combine data sets to have member_id, member_status, license plate, check-in date
get_fit_now_check_in |>
  right_join(get_fit_now_member,
             by = join_by(membership_id == id)) |>
  left_join(person,
             by = join_by(person_id == id,
                          name == name)) |> #two keys, name and id's
  inner_join(drivers_license,
             by = join_by(license_id == id)) |>
  mutate(plate_number = str_detect(string = plate_number,
                                    pattern = "H42W")) |>
  filter(gender == "male",
         membership_status == "gold",
         check_in_date == "20180109",
         plate_number == TRUE,
         str_detect(string = membership_id,
                    pattern = "^48Z")) |>
  pull(name)

#Note: Join functions changed from inner to right and left, ^ added to membership_id
      #pattern detection and membership_id str_detect moved to a filter instead of a mutate.
```

-   date (example must use functions from **lubridate**)

```{r}
#| label: wd-3-date

#Lab 5- Crime Scene Report

crime_scene_report |>
  mutate(date = ymd(date)) |> #numeric date becomes year-month-day date format
  filter(type == "murder",
         date == "2018-01-15",
         city == "SQL City") |>
  pull(description)

#Note: Original code was modified to include mutating to date format versus filtering
      #the date in numeric format.
```

**WD-4: I can modify existing variables and create new variables in a dataframe for a *variety* of data types (e.g., numeric, integer, character, factor, date).**

-   numeric (using `as.numeric()` is not sufficient)

```{r}
#| label: wd-4-numeric

#Lab 3 - Question 5
teacher_evals_clean <- evals |>
  rename(sex = gender) |> #rename gender column to 'sex'
  filter(no_participants >= 10) |> # remove all courses with fewer than 10 respondents
  mutate(teacher_id = as.factor(teacher_id), #change to a factor
         seniority = as.factor(seniority), #change to a factor
         question_no = question_no-900) |> #change question number to 1-10
  select(-(stud_grade_avg:stud_grade_var_coef_cur),
         -(class_duration:maximum_score)) #remove rows we don't need

```

-   character -- specifically a string (example must use functions from **stringr**)

```{r}
#| label: wd-4-string

#Lab 5 - Witness Interviews

interview |>
  inner_join(person, #keeps only rows in 'person' that are also in 'interview'
             by = join_by(person_id == id)) |> #join using key: person_id (interviews) and id (person)
  mutate(is_Annabel = str_detect(string = name,
                                 pattern = "Annabel"),
         .after = name) |> #new column after the name column with T/F if the person's first name is Annabel
  filter(address_street_name %in% c("Northwestern Dr",
                                    "Franklin Ave"),
         address_number == max(address_number) | #either highest address number *or* name is Annabel
         is_Annabel == TRUE) |>
  pull(transcript) #1 = Morty Schapiro, #2 = Annabel Miller
```

-   factor (example must use functions from **forcats**)

```{r}
#| label: wd-4-factor

#Lab 4 - Question 3

ca_childcare <- ca_childcare |> #I want the object to be updated with regions
  mutate(county_name = str_remove(string = county_name, 
                                  pattern = "County"),
         region = fct_collapse(.f = county_name,
                               "Superior California" = c("Butte ",
                                                         "Modoc ",
                                                         "Colusa ", 
                                                         "El Dorado ", 
                                                         "Glenn ", 
                                                         "Lassen ", 
                                                         "Nevada ", 
                                                         "Placer ", 
                                                         "Plumas ", 
                                                         "Sacramento ", 
                                                         "Shasta ", 
                                                         "Sierra ", 
                                                         "Siskiyou ",
                                                         "Sutter ",
                                                         "Tehama ",
                                                         "Yolo ",
                                                         "Yuba "),
                               "North Coast" = c("Del Norte ",
                                                 "Humboldt ",
                                                 "Lake ",
                                                 "Mendocino ",
                                                 "Napa ",
                                                 "Sonoma ",
                                                 "Trinity "),
                               "San Francisco Bay Area" = c("Alameda ",
                                                            "Contra Costa ",
                                                            "Marin ",
                                                            "San Francisco ",
                                                            "San Mateo ",
                                                            "Santa Clara ",
                                                            "Solano "),
                               "Northern San Joaquin Valley" = c("Alpine ",
                                                                 "Amador ",
                                                                 "Calaveras ",
                                                                 "Madera ",
                                                                 "Mariposa ",
                                                                 "Merced ",
                                                                 "Mono ",
                                                                 "San Joaquin ",
                                                                 "Stanislaus ",
                                                                 "Tuolumne "),
                               "Central Coast" = c("Monterey ", 
                                                   "San Benito ", 
                                                   "San Luis Obispo ", 
                                                   "Santa Barbara ", 
                                                   "Santa Cruz ", 
                                                   "Ventura "),
                               "Southern San Joaquin Valley" = c("Fresno ",
                                                                 "Inyo ",
                                                                 "Kern ",
                                                                 "Kings ",
                                                                 "Tulare "),
                               "Inland Empire" = c("Riverside ",
                                                   "San Bernardino "),
                               "Los Angeles County" = c("Los Angeles "),
                               "Orange County" = c("Orange "),
                               "San Diego Area - Imperial" = c("San Diego ",
                                                               "Imperial ")
                               ))

```

-   date (example must use functions from **lubridate**)

```{r}
#| label: wd-4-date

#Lab 5- Investigate Bowers's Statement

no_concert <- facebook_event_checkin |>
  mutate(date = ymd(date), #Convert to year-month-day format
         `date_2017` = if_else(year(date) != 2017, #If the year isn't 2017...
                            TRUE, #Then true
                            FALSE)) |> #If else, then false
  filter(event_name != "SQL Symphony Concert", #Keep only people who did not attend the concert
         `date_2017` == TRUE) #Keep only dates not in 2017

suspect_2 <- person |>
  anti_join(no_concert, #remove people who didn't attend the concert in 2017
            by = join_by(id == person_id)) |>
  inner_join(drivers_license,
             by = join_by(license_id == id),
             suffix = c("_person", "_license")) |>
  filter(gender == "female",
         height %in% 65|67,
         hair_color == "red",
         car_make == "Tesla",
         car_model == "Model S") |>
  inner_join(income,
            by = join_by(ssn)) |>
  slice_max(annual_income)

#Note: This code was re-written to include anti_join. A no_concert object was
      #created with all people who didn't attend the concert in years besides 2017. 
      #The other joining steps were re-ordered to include the anti_join at the 
      #beginning of the suspect_2 pipeline.
```

**WD-5: I can use mutating joins to combine multiple dataframes.**

-   `left_join()`
-   `right_join()`

```{r}
#| label: wd-5-right-and-left

#Lab 5- Applying Witness Accounts

#Combine data sets to have member_id, member_status, license plate, check-in date
get_fit_now_check_in |>
  right_join(get_fit_now_member,
             by = join_by(membership_id == id)) |>
  left_join(person,
             by = join_by(person_id == id,
                          name == name)) |> #two keys, name and id's
  inner_join(drivers_license,
             by = join_by(license_id == id)) |>
  mutate(plate_number = str_detect(string = plate_number,
                                    pattern = "H42W")) |>
  filter(gender == "male",
         membership_status == "gold",
         check_in_date == "20180109",
         plate_number == TRUE,
         str_detect(string = membership_id,
                    pattern = "^48Z")) |>
  pull(name)

#Note: Join functions changed from inner to right and left, ^ added to membership_id
      #pattern detection and membership_id str_detect moved to a filter instead of a mutate.
```

-   `inner_join()`

```{r}
#| label: wd-5-inner

#Lab 5 - Witness Interviews

interview |>
  inner_join(person, #keeps only rows in 'person' that are also in 'interview'
             by = join_by(person_id == id)) |> #join using key: person_id (interviews) and id (person)
  mutate(is_Annabel = str_detect(string = name,
                                 pattern = "Annabel"),
         .after = name) |> #new column after the name column with T/F if the person's first name is Annabel
  filter(address_street_name %in% c("Northwestern Dr",
                                    "Franklin Ave"),
         address_number == max(address_number) | #either highest address number *or* name is Annabel
         is_Annabel == TRUE) |>
  pull(transcript) #1 = Morty Schapiro, #2 = Annabel Miller
```

**WD-6: I can use filtering joins to filter rows from a dataframe.**

-   `semi_join()`

```{r}
#| label: wd-6-semi

##################################### Example 1 #####################################

#Lab 5- Bowers's Interview

interview |>
  semi_join(suspect_1, #Keep only the row containing the suspect found in previous step
            join_by(person_id)) |>
  pull(transcript)

#Note: Object created for suspect 1; filtering by person_id was replaced with a semi_join.

##################################### Example 2 #####################################

#Lab 5- Priestly's Interview
interview |>
  semi_join(suspect_2, #Keep only the row containing the suspect found in previous step
            join_by(person_id)) |>
  pull(transcript) #error: so no interview for Miranda Priestly

#Note: Object created for suspect 1; filtering by person_id was replaced with a semi_join.
```

-   `anti_join()`

```{r}
#| label: wd-6-anti

#Lab 5- Investigate Bowers's Statement

no_concert <- facebook_event_checkin |>
  mutate(date = ymd(date), #Convert to year-month-day format
         `date_2017` = if_else(year(date) != 2017, #If the year isn't 2017
                            TRUE, #Then true
                            FALSE)) |> #If else, then false
  filter(event_name != "SQL Symphony Concert", #Keep only people who did not attend the concert
         `date_2017` == TRUE) #Keep only dates not in 2017

suspect_2 <- person |>
  anti_join(no_concert, #remove people who didn't attend the concert in 2017
            by = join_by(id == person_id)) |>
  inner_join(drivers_license,
             by = join_by(license_id == id),
             suffix = c("_person", "_license")) |>
  filter(gender == "female",
         height %in% 65|67,
         hair_color == "red",
         car_make == "Tesla",
         car_model == "Model S") |>
  inner_join(income,
            by = join_by(ssn)) |>
  slice_max(annual_income)

#Note: This code was re-written to include anti_join. A no_concert object was
      #created with all people who didn't attend the concert in years besides 2017. 
      #The other joining steps were re-ordered to include the anti_join at the 
      #beginning of the suspect_2 pipeline.
```

**WD-7: I can pivot dataframes from long to wide and visa versa**

-   `pivot_longer()`

```{r}
#| label: wd-7-long

#Lab 4- Question 6

ca_childcare |>
  pivot_longer(cols = mc_infant:mc_preschool,
               names_to = "child_age",
               values_to = "w_median_price") |>
  mutate(child_age = fct_recode(.f = child_age, #Change the names of each level
                                "Infant" = "mc_infant",
                                "Toddler" = "mc_toddler",
                                "Preschool" = "mc_preschool"),
         child_age = fct_relevel(.f = child_age, #Change order of the levels
                                 "Infant",
                                 "Toddler",
                                 "Preschool")) |>
  ggplot(mapping = aes(x = study_year,
                       y = w_median_price,
                       color = fct_reorder2(.f = region,
                                            .x = study_year,
                                            .y = w_median_price))) + #Order the regions by median price
  geom_point(size = 0.5) +
  geom_smooth(method = "loess", 
              linewidth = 0.5) +
  facet_wrap(~child_age) +
  scale_x_continuous(n.breaks = 6) +
  scale_y_continuous(limits = c(100, 
                                500)) +
  theme_bw() +
  scale_color_manual(values = palette) + #use the palette made earlier
  labs(x = "Study Year",
       y = NULL,
       title = "Weekly Median Price for Center-Based Childcare ($)",
       color = "California Region") +
  theme(aspect.ratio = 1,
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 8),
        title = element_text(size = 8),
        legend.title = element_text(size = 9))
```

-   `pivot_wider()`

```{r}
#| label: wd-7-wide

#Lab 4 - Question 4

ca_childcare |> #This is the dataframe being used
  group_by(region, study_year) |> #Following summary will be applied to these two groups
  summarize(mhi_2018 = median(mhi_2018), #Find the median mhi_2018 values
            .groups = "drop") |> #Values now are median for each year at each county 
  filter(study_year %in% c(2008, 
                         2018)) |> #Keep only study years that include 2008 or 2018
  pivot_wider(id_cols = "region", #region stays from original table orientation 
              names_from = study_year, #I want 2008 and 2018 to become columns
              values_from = mhi_2018, #I want the corresponding values to be this
              names_prefix = "Med_household_income_") |>  #Add this prefix to the column names
  rename("Region" = "region") |> #Rename the region column to be capitalized
  select(c(`Region`, 
           starts_with("Med_household_income_"))) |> #Select Region rows that start with this prefix
  arrange(desc(`Med_household_income_2018`)) #Arrange this in descending order

#Note: More code comments added.
```

## Reproducibility

**R-1: I can create professional looking, reproducible analyses using RStudio projects, Quarto documents, and the here package.**

I've done this in the following provided assignments:

Top selections-

-   [Lab 5](https://github.com/EvaMoylan/lab-5-EvaMoylan)
-   [Lab 9](https://github.com/EvaMoylan/lab-9-EvaMoylan)
-   [Lab 8](https://github.com/EvaMoylan/lab-8-EvaMoylan)
-   [Challenge 7](https://github.com/EvaMoylan/lab-7-EvaMoylan)

**R-2: I can write well documented and tidy code.**

-   Example of **ggplot2** plotting

```{r}
#| label: r-2-1

#Challenge 3- Hot

#Box plot to compare weight within species
ggplot(data = surveys, #This is the dataframe that will be plotted
       mapping = aes(x = weight, #Weight will be on x-axis
                     y = species, #Species will be on y-axis
                     color = genus)) + #Color will denote genus
  geom_boxplot() + #This specifies the plot type (boxplot)
  scale_color_manual(values = cdPalette_grey) + #use previously made custom pallet
  annotate("text", #annotations will be text annotations
           y = 1:14, #Annotations will be on lines 1,2,3 etc. through 14
           x = 325, #Annotations will be placed at this value on the x-axis
           label = c("Neotoma", #N. abigula
                     "Chaetodipus", #C. baileyi
                     "Peromyscus", #P. eremicus
                     "Perognathus", #P. flavus
                     "Reithrodontomys", #R. fulvencens
                     "Sigmodon", #S. hispidus
                     "Onychomys", #O. leucogaster
                     "Peromyscus", #P. maniculatus
                     "Reithrodontomys", #R. megalotis
                     "Dipodomys", #D. merriami
                     "Dipodomys", #D. ordii
                     "Chaetodipus", #C. penicillatus
                     "Dipodomys", #O. spectabilis
                     "Onychomys")) + #O. torridus
  theme_bw() + #Black and white theme
  scale_x_continuous(limits = c(0, 350)) + #Neotoma gets cut off so expand x-axis limit
  labs(x = "Weight (g)", #x-axis label
       y = NULL, #No label for y-axis because information is in the subtitle/title
       subtitle = "Annotations represent genera", #This is the subtitle
       title = "Rodent Weight Across Species") + #This is the title
  theme(legend.position = "none") #Remove the legend 

#Note: Original code was modified to use only one annotate function for every species
      #name. The subtitle was also reworded and more code comments added. 
```

-   Example of **dplyr** pipeline

```{r}
#| label: r-2-2

#Lab 4 - Question 4

ca_childcare |> #This is the dataframe being used
  group_by(region, study_year) |> #Following summary will be applied to these two groups
  summarize(mhi_2018 = median(mhi_2018), #Find the median mhi_2018 values
            .groups = "drop") |> #Values now are median for each year at each county 
  filter(study_year %in% c(2008, 
                         2018)) |> #Keep only study years that include 2008 or 2018
  pivot_wider(id_cols = "region", #region stays from original table orientation 
              names_from = study_year, #I want 2008 and 2018 to become columns
              values_from = mhi_2018, #I want the corresponding values to be this
              names_prefix = "Med_household_income_") |>  #Add this prefix to the column names
  rename("Region" = "region") |> #Rename the region column to be capitalized
  select(c(`Region`, 
           starts_with("Med_household_income_"))) |> #Select Region rows that start with this prefix
  arrange(desc(`Med_household_income_2018`)) #Arrange this in descending order

#Note: More code comments added.
```

-   Example of function formatting

```{r}
#| label: r-2-3

#Lab 7- Question 4

rescale_01 <- function(x) { #Function takes vector 'x'
  
  stopifnot("Input must be numeric" = is.numeric(x)) #If the input isn't numeric, stop
  
  stopifnot("Input must be >= 1" = (length(x) >= 1)) #If the input isn't >= 1, stop
 
  range <- range(x, na.rm = TRUE) #Create an object of the max and min values of x
  
  return((x - range[1]) / (range[2] - range[1])) #Return x rescaled to be values within 0-1

}

#Note: More code comments added.
```

**R-3: I can write robust programs that are resistant to changes in inputs.**

-   Example -- any context

```{r}
#| label: r-3-example

#Lab 4 - Question 5

ca_childcare |>
  filter(study_year == 2018) |> #filter first to work with less data
  group_by(region, study_year) |>
  summarize(mhi_2018 = median(mhi_2018), #values now are median for each year at each county
            mc_infant = median(mc_infant),
            .groups = 'drop') |>
  pivot_wider(id_cols = "region", #region stays from original table orientation 
              names_from = study_year,
              values_from = c(mhi_2018,
                              mc_infant)) |>
  rename("Median_household_income_2018" = "mhi_2018_2018",
         "Median_infant_childcare$_2018" = "mc_infant_2018",
         "Region" = "region") |> 
  slice_min(`Median_infant_childcare$_2018`) #Superior CA has the lowest med childcare for infants in 2018

#Note: Changes to the origional code include moving the filter function to the
      #beginning of the pipeline and renaming the columns.
```

-   Example of function stops

```{r}
#| label: r-3-function-stops

#Lab 7- Question 4

rescale_01 <- function(x) { #Function takes vector 'x'
  
  stopifnot("Input must be numeric" = is.numeric(x)) #If the input isn't numeric, stop
  
  stopifnot("Input must be >= 1" = (length(x) >= 1)) #If the input isn't >= 1, stop
 
  range <- range(x, na.rm = TRUE) #Create an object of the max and min values of x
  
  return((x - range[1]) / (range[2] - range[1])) #Return x rescaled to be values within 0-1

}

#Note: More code comments added.
```

## Data Visualization & Summarization

**DVS-1: I can create visualizations for a *variety* of variable types (e.g., numeric, character, factor, date)**

-   at least two numeric variables

```{r}
#| label: dvs-1-num

#Lab 2- Question 4

#Scatter plots to compare weight and hindfoot length across species
ggplot(data = surveys,
       mapping = aes(x = weight,
                     y = hindfoot_length)) +
  geom_point(alpha = 0.3) + #Q5: Change transparency to see more points
  facet_wrap(~species) + #Q6: Facet by species
  theme_bw() + #Use this instead of classic to keep grid lines
  labs(x = "Weight (g)",
       y = NULL,
       subtitle = "Hindfoot Length (mm)", #Q8: Move y-axis title to top
       title = "Relationship Between Rodent Weight and Hindfoot Length Across Species")
```

-   at least one numeric variable and one categorical variable

```{r}
#| label: dvs-2-num-cat

#Challenge 3- Hot

#Box plot to compare weight within species
ggplot(data = surveys, #This is the dataframe that will be plotted
       mapping = aes(x = weight, #Weight will be on x-axis
                     y = species, #Species will be on y-axis
                     color = genus)) + #Color will denote genus
  geom_boxplot() + #This specifies the plot type (boxplot)
  scale_color_manual(values = cdPalette_grey) + #use previously made custom pallet
  annotate("text", #annotations will be text annotations
           y = 1:14, #Annotations will be on lines 1,2,3 etc. through 14
           x = 325, #Annotations will be placed at this value on the x-axis
           label = c("Neotoma", #N. abigula
                     "Chaetodipus", #C. baileyi
                     "Peromyscus", #P. eremicus
                     "Perognathus", #P. flavus
                     "Reithrodontomys", #R. fulvencens
                     "Sigmodon", #S. hispidus
                     "Onychomys", #O. leucogaster
                     "Peromyscus", #P. maniculatus
                     "Reithrodontomys", #R. megalotis
                     "Dipodomys", #D. merriami
                     "Dipodomys", #D. ordii
                     "Chaetodipus", #C. penicillatus
                     "Dipodomys", #O. spectabilis
                     "Onychomys")) + #O. torridus
  theme_bw() + #Black and white theme
  scale_x_continuous(limits = c(0, 350)) + #Neotoma gets cut off so expand x-axis limit
  labs(x = "Weight (g)", #x-axis label
       y = NULL, #No label for y-axis because information is in the subtitle/title
       subtitle = "Annotations represent genera", #This is the subtitle
       title = "Rodent Weight Across Species") + #This is the title
  theme(legend.position = "none") #Remove the legend 

#Note: Original code was modified to use only one annotate function for every species
      #name. The subtitle was also reworded and more code comments added. 
```

-   at least two categorical variables

```{r}
#| label: dvs-2-cat

#Challenge 3- Question 2

teacher_evals_compare |>
  ggplot(mapping = aes(x = sen_level, #Don't need to specify y because we want y to be a count of the other aesthetics
                       fill = SET_level)) +
  geom_bar(stat = "count",
           position = "stack") + 
  scale_fill_manual(values = c("steelblue",
                               "orange3")) +
  theme_bw() +
  labs(x = "Seniority of Instructor",
       y = NULL,
       subtitle = "Number of Sections",
       fill = "SET Level")
```

-   dates (timeseries plot)

```{r}
#| label: dvs-2-date

#Lab 4- Question 6

ca_childcare |>
  pivot_longer(cols = mc_infant:mc_preschool,
               names_to = "child_age",
               values_to = "w_median_price") |>
  mutate(child_age = fct_recode(.f = child_age, #Change the names of each level
                                "Infant" = "mc_infant",
                                "Toddler" = "mc_toddler",
                                "Preschool" = "mc_preschool"),
         child_age = fct_relevel(.f = child_age, #Change order of the levels
                                 "Infant",
                                 "Toddler",
                                 "Preschool")) |>
  ggplot(mapping = aes(x = study_year,
                       y = w_median_price,
                       color = fct_reorder2(.f = region,
                                            .x = study_year,
                                            .y = w_median_price))) + #Order the regions by median price
  geom_point(size = 0.5) +
  geom_smooth(method = "loess", 
              linewidth = 0.5) +
  facet_wrap(~child_age) +
  scale_x_continuous(n.breaks = 6) +
  scale_y_continuous(limits = c(100, 
                                500)) +
  theme_bw() +
  scale_color_manual(values = palette) + #use the palette made earlier
  labs(x = "Study Year",
       y = NULL,
       title = "Weekly Median Price for Center-Based Childcare ($)",
       color = "California Region") +
  theme(aspect.ratio = 1,
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 8),
        title = element_text(size = 8),
        legend.title = element_text(size = 9))
```

**DVS-2: I use plot modifications to make my visualization clear to the reader.**

-   I can ensure people don't tilt their head

```{r}
#| label: dvs-2-1

#Challenge 3- Hot

#Box plot to compare weight within species
ggplot(data = surveys, #This is the dataframe that will be plotted
       mapping = aes(x = weight, #Weight will be on x-axis
                     y = species, #Species will be on y-axis
                     color = genus)) + #Color will denote genus
  geom_boxplot() + #This specifies the plot type (boxplot)
  scale_color_manual(values = cdPalette_grey) + #use previously made custom pallet
  annotate("text", #annotations will be text annotations
           y = 1:14, #Annotations will be on lines 1,2,3 etc. through 14
           x = 325, #Annotations will be placed at this value on the x-axis
           label = c("Neotoma", #N. abigula
                     "Chaetodipus", #C. baileyi
                     "Peromyscus", #P. eremicus
                     "Perognathus", #P. flavus
                     "Reithrodontomys", #R. fulvencens
                     "Sigmodon", #S. hispidus
                     "Onychomys", #O. leucogaster
                     "Peromyscus", #P. maniculatus
                     "Reithrodontomys", #R. megalotis
                     "Dipodomys", #D. merriami
                     "Dipodomys", #D. ordii
                     "Chaetodipus", #C. penicillatus
                     "Dipodomys", #O. spectabilis
                     "Onychomys")) + #O. torridus
  theme_bw() + #Black and white theme
  scale_x_continuous(limits = c(0, 350)) + #Neotoma gets cut off so expand x-axis limit
  labs(x = "Weight (g)", #x-axis label
       y = NULL, #No label for y-axis because information is in the subtitle/title
       subtitle = "Annotations represent genera", #This is the subtitle
       title = "Rodent Weight Across Species") + #This is the title
  theme(legend.position = "none") #Remove the legend 

#Note: Original code was modified to use only one annotate function for every species
      #name. The subtitle was also reworded and more code comments added. 
```

-   I can modify the text in my plot to be more readable
-   I can reorder my legend to align with the colors in my plot

```{r}
#| label: dvs-2-2 & dvs-2-3

#Lab 4- Question 6

ca_childcare |>
  pivot_longer(cols = mc_infant:mc_preschool,
               names_to = "child_age",
               values_to = "w_median_price") |>
  mutate(child_age = fct_recode(.f = child_age, #Change the names of each level
                                "Infant" = "mc_infant",
                                "Toddler" = "mc_toddler",
                                "Preschool" = "mc_preschool"),
         child_age = fct_relevel(.f = child_age, #Change order of the levels
                                 "Infant",
                                 "Toddler",
                                 "Preschool")) |>
  ggplot(mapping = aes(x = study_year,
                       y = w_median_price,
                       color = fct_reorder2(.f = region,
                                            .x = study_year,
                                            .y = w_median_price))) + #Order the regions by median price
  geom_point(size = 0.5) +
  geom_smooth(method = "loess", 
              linewidth = 0.5) +
  facet_wrap(~child_age) +
  scale_x_continuous(n.breaks = 6) +
  scale_y_continuous(limits = c(100, 
                                500)) +
  theme_bw() +
  scale_color_manual(values = palette) + #use the palette made earlier
  labs(x = "Study Year",
       y = NULL,
       title = "Weekly Median Price for Center-Based Childcare ($)",
       color = "California Region") +
  theme(aspect.ratio = 1,
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 8),
        title = element_text(size = 8),
        legend.title = element_text(size = 9))
```

**DVS-3: I show creativity in my visualizations**

-   I can use non-standard colors

```{r}
#| label: dvs-3-1

#Lab 4- Question 6

palette <- colorRampPalette(brewer.pal(8,"Accent"))(10) #Brewer palette only has 8 colors, so make a palette with 10

ca_childcare |>
  pivot_longer(cols = mc_infant:mc_preschool,
               names_to = "child_age",
               values_to = "w_median_price") |>
  mutate(child_age = fct_recode(.f = child_age, #Change the names of each level
                                "Infant" = "mc_infant",
                                "Toddler" = "mc_toddler",
                                "Preschool" = "mc_preschool"),
         child_age = fct_relevel(.f = child_age, #Change order of the levels
                                 "Infant",
                                 "Toddler",
                                 "Preschool")) |>
  ggplot(mapping = aes(x = study_year,
                       y = w_median_price,
                       color = fct_reorder2(.f = region,
                                            .x = study_year,
                                            .y = w_median_price))) + #Order the regions by median price
  geom_point(size = 0.5) +
  geom_smooth(method = "loess", 
              linewidth = 0.5) +
  facet_wrap(~child_age) +
  scale_x_continuous(n.breaks = 6) +
  scale_y_continuous(limits = c(100, 
                                500)) +
  theme_bw() +
  scale_color_manual(values = palette) + #use the palette made earlier
  labs(x = "Study Year",
       y = NULL,
       title = "Weekly Median Price for Center-Based Childcare ($)",
       color = "California Region") +
  theme(aspect.ratio = 1,
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 8),
        title = element_text(size = 8),
        legend.title = element_text(size = 9))
```

-   I can use annotations

```{r}
#| label: dvs-3-2

#Challenge 3- Hot

#Box plot to compare weight within species
ggplot(data = surveys, #This is the dataframe that will be plotted
       mapping = aes(x = weight, #Weight will be on x-axis
                     y = species, #Species will be on y-axis
                     color = genus)) + #Color will denote genus
  geom_boxplot() + #This specifies the plot type (boxplot)
  scale_color_manual(values = cdPalette_grey) + #use previously made custom pallet
  annotate("text", #annotations will be text annotations
           y = 1:14, #Annotations will be on lines 1,2,3 etc. through 14
           x = 325, #Annotations will be placed at this value on the x-axis
           label = c("Neotoma", #N. abigula
                     "Chaetodipus", #C. baileyi
                     "Peromyscus", #P. eremicus
                     "Perognathus", #P. flavus
                     "Reithrodontomys", #R. fulvencens
                     "Sigmodon", #S. hispidus
                     "Onychomys", #O. leucogaster
                     "Peromyscus", #P. maniculatus
                     "Reithrodontomys", #R. megalotis
                     "Dipodomys", #D. merriami
                     "Dipodomys", #D. ordii
                     "Chaetodipus", #C. penicillatus
                     "Dipodomys", #O. spectabilis
                     "Onychomys")) + #O. torridus
  theme_bw() + #Black and white theme
  scale_x_continuous(limits = c(0, 350)) + #Neotoma gets cut off so expand x-axis limit
  labs(x = "Weight (g)", #x-axis label
       y = NULL, #No label for y-axis because information is in the subtitle/title
       subtitle = "Annotations represent genera", #This is the subtitle
       title = "Rodent Weight Across Species") + #This is the title
  theme(legend.position = "none") #Remove the legend 

#Note: Original code was modified to use only one annotate function for every species
      #name. The subtitle was also reworded and more code comments added. 
```

-   I can be creative...

```{r}
#| label: dvs-3-3

##################################### Example 1 #####################################

#Lab 7- Question 2

fish_data |>
  filter(is.na(weight) == TRUE) |> 
  mutate(trip = case_when( #this mutate added to change labels
    trip == 1 ~ "Trip 1",
    trip == 2 ~ "Trip 2"),
    section = fct_recode(.f = section,
                              "Scotty Brown" = "ScottyBrown")) |>
  ggplot(mapping = aes(x = year,
                       fill = section)) +
  geom_bar(stat = "count",
           position = "stack") +
  facet_wrap(~ trip) +
  scale_fill_manual(values = c("tomato",
                               "steelblue")) +
  scale_x_continuous(n.breaks = 10) +
  theme_bw() +
  labs(x = "Year",
       y = NULL,
       title = str_c("Frequency of Missing Fish Weights (g) for the ",
                     "<span style = 'color:#FF6347'>**Johnsrud**</span>",
                     " and <span style = 'color:#4682B4'>**Scotty Brown**</span>",
                     " Sections of the Blackfoot River"),
       fill = "Study Section") +
  theme(aspect.ratio = 0.5,
        legend.position = "none",
        axis.text.x = element_text(size = 7.5),
        plot.title = ggtext::element_markdown())
  
#Note: Legend removed and color-coded title added.

##################################### Example 2 #####################################

#Challenge 7- Question 4

##| fig-cap: "Figure 1. The distribution of trout condition indeces across study years
            #1988 to 2006 in the Johsrud and Scotty Brown study regions. The green
            #dotted lines represent the healthy index range of 0.8 to 1."

fish_clean |>
  mutate(condition = condition.index(weight, 
                                     length)) |>
  filter(condition <= 2.5) |>
  ggplot(mapping = aes(x = year,
                       y = condition,
                       color = section)) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  facet_wrap(~ section) +
  scale_color_manual(values = c("tomato", "steelblue")) +
  scale_x_continuous(n.breaks = 10) +
  theme_bw() +
  geom_hline(yintercept = c(1, 0.8), 
             linetype = "dashed", 
             color = "darkolivegreen") +
  labs(x = "Study Year",
       y = NULL,
       subtitle = "Condition Index",
       title = "Fish Condition Across Study Sites",
       fill = "Study Section") +
  theme(aspect.ratio = 0.75,
        axis.text.x = element_text(angle = 45, 
                                   vjust = 0.75),
        legend.position = "none")
```

**DVS-4: I can calculate numerical summaries of variables.**

-   Example using `summarize()`

```{r}
#| label: dvs-4-summarize

#Lab 3- Question 11

#Teacher with the highest average percent failure
teacher_evals_clean |>
  filter(seniority == 1) |> #Keep only instructors with 1 year of experience
  group_by(teacher_id) |>
  summarize(percent_failed_cur = mean(percent_failed_cur)) |>
  slice_max(percent_failed_cur)

#Teachers with the lowest average percent failure
teacher_evals_clean |>
  filter(seniority == 1) |> #Keep only instructors with 1 year of experience
  group_by(teacher_id) |>
  summarise(percent_failed_cur = mean(percent_failed_cur)) |>
  slice_min(percent_failed_cur)
```

-   Example using `across()`

```{r}
#| label: dvs-4-across

#Lab 3- Question 7

teacher_evals_clean |>
  group_by(teacher_id, course_id) |> 
  summarize(
    across(.col = question_no:sex, #summarize across these columns...
           .fns = ~sum(is.na(.x))), #for these 'x' entries, keep if NA
    .groups = "drop" #un-group
    ) |> 
  filter(
    if_any(.col = question_no:sex,
           .fns = ~.x != 0)) #if any entries in these columns are not equal to 0, keep that row
```

**DVS-5: I can find summaries of variables across multiple groups.**

-   Example 1

```{r}
#| label: dvs-5-1

#Lab 3- Question 10

#Teachers with the highest average rating for Q1
teacher_evals_clean |>
  filter(question_no == 1) |> 
  group_by(teacher_id, SET_score_avg) |>
  summarise(SET_score_avg = mean(SET_score_avg),
            .groups = "drop") |> #Average Q1 score for each teacher
  filter(SET_score_avg == max(SET_score_avg) |
         SET_score_avg == min(SET_score_avg)
         )

#Note: Original code was modified to filter using max and min arguments in one
      #pipeline instead of slice_min and slice_max in seperate pipelines.
```

-   Example 2

```{r}
#| label: dvs-5-2

#Lab 3- Question 9

#Which teacher-class combinations answered all 9 questions?
teacher_evals_clean |>
  group_by(teacher_id, course_id) |>
  summarize(no_9 = n(),
            .groups = 'drop') |> #this is important to specify what statistic to use
  filter(no_9 == 9) |> 
  distinct(teacher_id,course_id) |>
  nrow()

#Note: Original code was modified to use summarize to count the number of questions
      #per teacher and course combination.
```

**DVS-6: I can create tables which make my summaries clear to the reader.**

-   Example 1

```{r}
#| label: dvs-6-1

#Lab 4 - Question 4

ca_childcare |> #This is the dataframe being used
  group_by(region, study_year) |> #Following summary will be applied to these two groups
  summarize(mhi_2018 = median(mhi_2018), #Find the median mhi_2018 values
            .groups = "drop") |> #Values now are median for each year at each county 
  filter(study_year %in% c(2008, 
                         2018)) |> #Keep only study years that include 2008 or 2018
  pivot_wider(id_cols = "region", #region stays from original table orientation 
              names_from = study_year, #I want 2008 and 2018 to become columns
              values_from = mhi_2018, #I want the corresponding values to be this
              names_prefix = "Med_household_income_") |>  #Add this prefix to the column names
  rename("Region" = "region") |> #Rename the region column to be capitalized
  select(c(`Region`, 
           starts_with("Med_household_income_"))) |> #Select Region rows that start with this prefix
  arrange(desc(`Med_household_income_2018`)) #Arrange this in descending order

#Note: More code comments added.
```

-   Example 2

```{r}
#| label: dvs-6-2

#Lab 9 - Question 2

results |>
  count(Correct_Pairs) |>
  pivot_wider(names_from = Correct_Pairs,
              values_from = n) |>
  reframe(across(.cols = everything(),
                 .f = ~ (.x / 10000))
          ) |>
  mutate('3' = as.integer('0'),
         .after = '2') |> #Looks like there are no 3's, so add that to the table
  gt() |>
  tab_header(title = "Simulated Baby-Parent Matches",
             subtitle = "Proportion of simulations where 0, 1, 2, 3, and 4 babies were given to their correct parents."
  ) |>
  tab_footnote(footnote = "Note: 10,000 pairings simulated.") |>
  tab_style(
    style = cell_text(align = "center",
                      weight = "bold"), 
    locations = cells_column_labels()
  ) |>
  tab_style(
    style = cell_text(align = "center"), 
    locations = cells_body()
  ) |>
  fmt_percent(columns = everything())

#Note: Changes made include using fmt_percent to re-label proportions, and footnote added.
```

**DVS-7: I show creativity in my tables.**

-   Example 1

```{r}
#| label: dvs-7-1

#Lab 9 - Question 2

results |>
  count(Correct_Pairs) |>
  pivot_wider(names_from = Correct_Pairs,
              values_from = n) |>
  reframe(across(.cols = everything(),
                 .f = ~ (.x / 10000))
          ) |>
  mutate('3' = as.integer('0'),
         .after = '2') |> #Looks like there are no 3's, so add that to the table
  gt() |>
  tab_header(title = "Simulated Baby-Parent Matches",
             subtitle = "Proportion of simulations where 0, 1, 2, 3, and 4 babies were given to their correct parents."
  ) |>
  tab_footnote(footnote = "Note: 10,000 pairings simulated.") |>
  tab_style(
    style = cell_text(align = "center",
                      weight = "bold"), 
    locations = cells_column_labels()
  ) |>
  tab_style(
    style = cell_text(align = "center"), 
    locations = cells_body()
  ) |>
  fmt_percent(columns = everything())

#Note: Changes made include using fmt_percent to re-label proportions, and footnote added.
```

-   Example 2

```{r}
#| label: dvs-7-2

#Lab 8 - Question 4

tibble(Variable = names(fish),
       NA_Count = map_int(.x = fish,
                          .f = ~sum(is.na(.x))
                          )
       ) |>
  mutate(Variable = str_replace(string = Variable,
                                pattern = "^[a-z]",
                                replace = toupper)) |>
#str_replace( ) description used to figure out 'toupper' replaces letters with uppercase
  pivot_wider(names_from = Variable,
              values_from = NA_Count) |>
  knitr::kable("html",
               align = "c",
               caption = "Table 1: Frequency of missing values in the Blackfoot River Trout dataset across study years 1988-2006.") |> 
  #kable() description used to find arguments
  kable_styling(bootstrap_options = "striped")
```

## Program Efficiency

**PE-1: I can write concise code which does not repeat itself.**

-   using a single function call with multiple inputs (rather than multiple function calls)

```{r}
#| label: pe-1-one-call

#Lab 5 - Witness Interviews

#Join interviews data and person data, to find witnesses based on their address
interview |>
  inner_join(person, #keeps only rows in 'person' that are also in 'interview'
             by = join_by(person_id == id)) |> #join using key: person_id (interviews) and id (person)
  mutate(is_Annabel = str_detect(string = name,
                                 pattern = "Annabel"),
         .after = name) |> #new column after the name column with T/F if the person's first name is Annabel
  filter(address_street_name %in% c("Northwestern Dr",
                                    "Franklin Ave"),
         address_number == max(address_number) | #either highest address number *or* name is Annabel
         is_Annabel == TRUE) |>
  pull(transcript) #1 = Morty Schapiro, #2 = Annabel Miller
```

-   `across()`

```{r}
#| label: pe-1-across

#Lab 3- Question 7

teacher_evals_clean |>
  group_by(teacher_id, course_id) |> 
  summarize(
    across(.col = question_no:sex, #summarize across these columns...
           .fns = ~sum(is.na(.x))), #for these 'x' entries, keep if NA
    .groups = "drop" #un-group
    ) |> 
  filter(
    if_any(.col = question_no:sex,
           .fns = ~.x != 0)) #if any entries in these columns are not equal to 0, keep that row
```

-   `map()` functions

```{r}
#| label: pe-1-map-1

#Lab 8- Question 1

tibble(Variable = names(surveys),
       Data_Type = map_chr(.x = surveys,
                           .f = ~ typeof(.x)
                           )
       ) |>
  pivot_wider(names_from = Variable,
              values_from = Data_Type) |>
  knitr::kable("html",
               align = "c") |>
  kable_styling(bootstrap_options = "bordered")
```

**PE-2: I can write functions to reduce repetition in my code.**

-   Function that operates on vectors

```{r}
#| label: pe-2-1

#Lab 7- Question 4

rescale_01 <- function(x) { #Function takes vector 'x'
  
  stopifnot("Input must be numeric" = is.numeric(x)) #If the input isn't numeric, stop
  
  stopifnot("Input must be >= 1" = (length(x) >= 1)) #If the input isn't >= 1, stop
 
  range <- range(x, na.rm = TRUE) #Create an object of the max and min values of x
  
  return((x - range[1]) / (range[2] - range[1])) #Return x rescaled to be values within 0-1

}

#Note: Code comments added.
```

-   Function that operates on data frames

```{r}
#| label: pe-2-2

#Lab 7- Question 8

rescale_column <- function(df, x, y) {
 
  stopifnot("Input is not a data frame" = (is.data.frame(df)
                                           )
            )
  
  df <- df |>
    mutate(across(.cols = {{x}},
                  .fns = ~rescale_01(.x)
                  )
           ) |>
    
    mutate(across(.cols = {{y}},
                  .fns = ~rescale_01(.x)
                  )
    )

  return(df)
}
```

**PE-3: I can use iteration to reduce repetition in my code.**

-   `across()`

```{r}
#| label: pe-3-across

#Lab 7- Question 1

fish_data |>
  summarize(
    across(.col = everything(),
           .fns = ~sum(is.na(.x)))
  ) |>
  filter(
    if_any(.col = everything(),
           .fns = ~.x != 0))

```

-   `map()` function with **one** input (e.g., `map()`, `map_chr()`, `map_dbl()`, etc.)

```{r}
#| label: pe-3-map-1

#Lab 8- Question 1

tibble(Variable = names(surveys),
       Data_Type = map_chr(.x = surveys,
                           .f = ~ typeof(.x)
                           )
       ) |>
  pivot_wider(names_from = Variable,
              values_from = Data_Type) |>
  knitr::kable("html",
               align = "c") |>
  kable_styling(bootstrap_options = "bordered")
  
```

-   `map()` function with **more than one** input (e.g., `map_2()` or `pmap()`)

```{r}
#| label: pe-3-map-2

#Lab 9- Question 6

all_simulations <- grid |> 
  mutate(simulated_means = pmap(.l = list(n = n, 
                                          df = df), 
                                .f = simulate_means)
         ) |> 
  unnest(cols = simulated_means) 

```

**PE-4: I can use modern tools when carrying out my analysis.**

-   I can use functions which are not superseded or deprecated

```{r}
#| label: pe-4-1

#Lab 3- Question 7

teacher_evals_clean |>
  group_by(teacher_id, 
           course_id) |> 
  summarize(
    across(.col = question_no:sex, #summarize across these columns...
           .fns = ~sum(is.na(.x))), #for these 'x' entries, keep if NA
    .groups = "drop" #un-group
    ) |> 
  filter(
    if_any(.col = question_no:sex,
           .fns = ~.x != 0)) #if any entries in these columns are not equal to 0, keep that row
```

-   I can connect a data wrangling pipeline into a `ggplot()`

```{r}
#| label: pe-4-2

#Lab 4 - Question 6

ca_childcare |>
  pivot_longer(cols = mc_infant:mc_preschool,
               names_to = "child_age",
               values_to = "w_median_price") |>
  mutate(child_age = fct_recode(.f = child_age, #Change the names of each level
                                "Infant" = "mc_infant",
                                "Toddler" = "mc_toddler",
                                "Preschool" = "mc_preschool"),
         child_age = fct_relevel(.f = child_age, #Change order of the levels
                                 "Infant",
                                 "Toddler",
                                 "Preschool")) |>
  ggplot(mapping = aes(x = study_year,
                       y = w_median_price,
                       color = fct_reorder2(.f = region,
                                            .x = study_year,
                                            .y = w_median_price))) + #Order the regions by median price
  geom_point(size = 0.5) +
  geom_smooth(method = "loess", 
              linewidth = 0.5) +
  facet_wrap(~child_age) +
  scale_x_continuous(n.breaks = 6) +
  scale_y_continuous(limits = c(100, 
                                500)) +
  theme_bw() +
  scale_color_manual(values = palette) + #use the palette made earlier
  labs(x = "Study Year",
       y = NULL,
       title = "Weekly Median Price for Center-Based Childcare ($)",
       color = "California Region") +
  theme(aspect.ratio = 1,
        axis.text = element_text(size = 6),
        axis.title = element_text(size = 8),
        title = element_text(size = 8),
        legend.title = element_text(size = 9))
```

## Data Simulation & Statistical Models

**DSSM-1: I can simulate data from a *variety* of probability models.**

-   Example 1

```{r}
#| label: dsm-1-1

#Lab 9- Question 1

randomBabies <- function(n = 4){ #This sets the default number of babies(n) to 4 if not otherwise specified
  
  baby_data <- tibble(baby = 1:n,
                      parent = sample(1:n,
                                      size = n,
                                      replace = FALSE)
  )
  
  baby_pairs <- baby_data |>
    mutate(correct_pair = if_else(parent == baby,
                                  TRUE,
                                  FALSE)) |>
    summarize(correct_pair = sum(correct_pair)) |>
    pull(correct_pair)
  
  return(baby_pairs) #return number of correct pairs
                  
}

results <- map_int(.x = 1:10000,
                   .f = ~ randomBabies(n = 4)
                   )

```

-   Example 2

```{r}
#| label: dsm-1-2

#Lab 9- Questions 4-6

#Simulation function
simulate_means <- function(n, df){
  map_dbl(.x = 1:n, 
          .f = ~rchisq(n = 100, df = df) %>% mean()
          )
}

#Create grid
grid <- crossing(n = 10^seq(from = 1, 
                         to = 4,
                         by = 1), 
                 df = 10)

#Simulate means across the grid
all_simulations <- grid |> 
  mutate(simulated_means = pmap(.l = list(n = n, 
                                          df = df), 
                                .f = simulate_means)
         ) |> 
  unnest(cols = simulated_means)

```

**DSSM-2: I can conduct common statistical analyses in R.**

-   Example 1

```{r}
#| label: dsm-2-1

#Lab 1- Question 10

#Conduct a two-sample t-test assuming unequal variances and a two-sided alternative.
#Is tooth length different between supplement delivery methods?
t.test(formula = len ~ supp, 
       data = ToothGrowth, 
       alternative = "two.sided", 
       var.equal = FALSE)

#Note: Specifiying the formula argument was added to the origional code.
      #(i.e., formula = len ~ supp, instead of len ~ supp)
```

-   Example 2

```{r}
#| label: dsm-2-2

#Challenge 3- Question 3

# Chi-squared test of independence between SET level and instructor seniority
chisq.test(teacher_evals_compare$SET_level, teacher_evals_compare$sen_level) #output: p = 0.001

#Note: Original code was changed to call on SET_level and sen_level in the
      #teacher_evals_compare dataset within the chisq.test function instead of
      #creating a table seperately and calling on the table.
```

## Revising My Thinking

<!-- How did you revise your thinking throughout the course? How did you revise your thinking on the code examples you have provided in your portfolio? -->

<!-- For the revisions included in your Portfolio, to help me understand the nature of your revisions, please denote somehow the feedback I provided you (e.g., boldface, italics, colored text) before your revisions. -->

When I was provided growing feedback on assignments, I submitted revisions for all but some of the questions. Additionally, if I received feedback on questions that I received a success on, I tried my best to also apply those revisions to my code and related code in future assignments. When revising my code, I wrote thoughtful reflections on why the changes were necessary and how I will use this information for future programming. A revision that I am proud of was from Lab 2, which applied to questions 2 and 3:

*"Originally, I used the print( ) function to show a tibble of the data to get the information on rows, columns and data types. Reconsidering this decision, it is more efficient to use glimpse( ). While print( ) gives the size of the tibble, you need to scroll to look at every column individually to see the different data types and the result gives a message not an output. But, glimpse( ) gives the same information in the form of an output. In the future, when I need this information I will use the glimpse( ) function instead!"*

## Extending My Thinking

<!-- How did you extended your thinking throughout the course? How did you extend your thinking on the code examples you have provided in your portfolio? -->

I feel confident in my effort to extend my thinking so far in this course. I made an effort to push myself on challenge assignments and labs when possible. For example, for Challenge 3, I completed the 'hot' assignment because the annotate( ) function was new to me and I learned new ggplot2 skills. For Lab 9, I also completed the optional data simulation section to push myself and become more comfortable with this learning target. For labs and challenge assignments where we were required to re-create plots, I also tried to match the appearance of the plot (i.e. style, colors) as close as possible to the example instead of only matching the visualization of the data.

## Peer Support & Collaboration

<!-- Include an image or a description of feedback you gave that you are proud of (either in a peer review or in Discord). -->

![](images/Screenshot%202024-11-03%20at%209.36.52%20PM.png){width="470"}

<!-- Include a description of how you grew as a collaborator through the weekly pair programming activities.   -->

During weekly pair programming activities, I have grown in my ability to communicate writing code with others. The exercise of having one group member verbally coding and another developing that code has also helped my ability to understand and write code from hearing someone else describe it. I have enjoyed seeing the different ways we both might approach the same problem and this also improved my ability to work through different methods to get the correct output from our code.
